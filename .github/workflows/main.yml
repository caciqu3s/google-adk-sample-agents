name: Python and Terraform CI/CD

on:
  pull_request:
    branches:
      - main
    paths:
      - '**/*.py'
      - 'pyproject.toml'
      - 'poetry.lock'
      - 'agents/**' # Catch agent-related files
      - 'terraform/**'
      - '.github/workflows/ci-cd.yml'

  push:
    branches:
      - main
    paths:
      - '**/*.py'
      - 'pyproject.toml'
      - 'poetry.lock'
      - 'agents/**'
      - 'terraform/**'
      - '.github/workflows/ci-cd.yml'

# Required for google-github-actions/auth using Workload Identity Federation
permissions:
  contents: read
  id-token: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      python_changed: ${{ steps.changes.outputs.python_changed }}
      terraform_changed: ${{ steps.changes.outputs.terraform_changed }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch history for diffing on push events

      - name: Get changed files
        id: changed_files
        uses: tj-actions/changed-files@v44 # Use a specific version
        with:
          files_yaml: |
            python:
              - '**/*.py'
              - 'pyproject.toml'
              - 'poetry.lock'
              - 'agents/**'
            terraform:
              - 'terraform/**'

      - name: Determine changed areas
        id: changes
        run: |
          echo "python_changed=${{ steps.changed_files.outputs.python_any_changed }}" >> $GITHUB_OUTPUT
          echo "terraform_changed=${{ steps.changed_files.outputs.terraform_any_changed }}" >> $GITHUB_OUTPUT

  python-pr-check:
    needs: check-changes
    if: github.event_name == 'pull_request' && needs.check-changes.outputs.python_changed == 'true'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13' # Match your project's required version

      - name: Install Poetry
        run: pipx install poetry

      - name: Install dependencies
        run: poetry install --no-root

      # Add your test and lint steps here
      # - name: Run tests
      #   run: poetry run pytest tests/

      # - name: Run linter
      #   run: poetry run ruff check .

      - name: Placeholder Test/Lint
        run: echo "Python Build/Test checks would run here."

  terraform-pr-plan:
    needs: check-changes
    if: github.event_name == 'pull_request' && needs.check-changes.outputs.terraform_changed == 'true'
    runs-on: ubuntu-latest
    environment: production
    defaults:
      run:
        working-directory: ./terraform
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0" # Or your desired version

      - name: Terraform Init
        id: init
        run: terraform init

      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color

      - name: Terraform Plan
        id: plan
        run: terraform plan -no-color -input=false

      # Optional: Add step to comment plan output on the PR

  deploy-python-agents:
    needs: [check-changes, deploy-terraform]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.check-changes.outputs.python_changed == 'true'
    runs-on: ubuntu-latest
    environment: production # Optional: Define a GitHub environment for protection rules
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - name: Set up gcloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Install jq (for reading deploy.json)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Deploy Agents using gcloud
        env:
          GOOGLE_CLOUD_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
          GOOGLE_CLOUD_LOCATION: ${{ secrets.GCP_REGION }}
        run: |
          echo "Deploying single agent service to Cloud Run using gcloud..."

          # Construct the DB instance connection name once
          DB_INSTANCE_CONNECTION_NAME="${GOOGLE_CLOUD_PROJECT}:${GOOGLE_CLOUD_LOCATION}:main-instance"

          # Read the deployment config file
          config_file="agents/deploy.json"
          if [ ! -f "$config_file" ]; then
             echo "Error: Deployment config file not found at $config_file"
             exit 1
          fi
          config_json=$(cat "$config_file")

          # NOTE: This assumes the root Dockerfile and main.py are suitable for the combined service.

          # Get service name from the config
          SERVICE_NAME=$(echo "$config_json" | jq -r '.service_name // ""' )

          if [ -z "$SERVICE_NAME" ]; then
            echo "Error: 'service_name' not found or empty in $config_file."
            exit 1
          fi

          # Initialize ENV_VARS string only with Project and Location
          ENV_VARS="GOOGLE_CLOUD_PROJECT=${GOOGLE_CLOUD_PROJECT}"
          ENV_VARS+=",GOOGLE_CLOUD_LOCATION=$GOOGLE_CLOUD_LOCATION"

          # Process env vars defined in the config
          env_vars_json=$(echo "$config_json" | jq -c '.env_vars // []')

          # Use process substitution and mapfile for safer parsing
          mapfile -t env_items < <(echo "$env_vars_json" | jq -c '.[]')

          for item_json in "${env_items[@]}"; do
            var_name=$(echo "$item_json" | jq -r '.name')
            plain_value=$(echo "$item_json" | jq -r '.value // ""' )
            secret_name=$(echo "$item_json" | jq -r '.secret // ""' )
            secret_version=$(echo "$item_json" | jq -r '.version // "latest"')

            if [ -n "$secret_name" ]; then
              # It's a secret reference
              ENV_VARS+=",$var_name=secret:$secret_name:$secret_version"
            elif [ -n "$plain_value" ] || [ "$var_name" = "DB_INSTANCE_CONNECTION_NAME" ]; then # Include placeholder
              # It's a plain value or the placeholder
              quoted_value=$(printf '%q' "$plain_value")
              ENV_VARS+=",$var_name=$quoted_value"
            fi
          done

          # Replace the placeholder with the actual constructed value
          ENV_VARS=${ENV_VARS//__INSTANCE_CONNECTION_NAME_PLACEHOLDER__/$DB_INSTANCE_CONNECTION_NAME}

          # Build the gcloud deploy command
          deploy_cmd="gcloud run deploy \"$SERVICE_NAME\""
          deploy_cmd+=" --source ." # Build from root Dockerfile
          deploy_cmd+=" --project \"$GOOGLE_CLOUD_PROJECT\""
          deploy_cmd+=" --region \"$GOOGLE_CLOUD_LOCATION\""
          # Escape the ENV_VARS string for safe inclusion in the command
          escaped_env_vars=$(printf '%q' "$ENV_VARS")
          deploy_cmd+=" --set-env-vars=$escaped_env_vars"
          deploy_cmd+=" --platform managed"

          # Add --allow-unauthenticated flag based on deploy.json (if needed)
          if [ "$(echo "$config_json" | jq -r '.allow_unauthenticated // false')" = "true" ]; then
            deploy_cmd+=" --allow-unauthenticated"
          fi

          # Add --no-traffic flag based on deploy.json (optional, useful for blue/green)
          if [ "$(echo "$config_json" | jq -r '.no_traffic // false')" = "true" ]; then
             deploy_cmd+=" --no-traffic"
          fi

          echo "Executing deployment for $SERVICE_NAME..."
          echo "Command: $deploy_cmd" # Print command for debugging
          eval $deploy_cmd # Execute the built command

  deploy-terraform:
    needs: check-changes
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production # Optional: Define a GitHub environment for protection rules
    defaults:
      run:
        working-directory: ./terraform
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SA_EMAIL }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0" # Or your desired version

      - name: Terraform Init
        run: terraform init

      - name: Terraform Apply
        run: terraform apply -auto-approve -input=false